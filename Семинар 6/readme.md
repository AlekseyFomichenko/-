# Домашняя работа
#### Взять реализованный код в рамках семинара 4 и продемонстрировать применение принципов, усвоенных на семинаре.Нужно в проекте создать файл ReadMe.md отметить участки кода, которые рефакторим, какой принцип применяем и почему. Формат сдачи: ссылка на гитхаб проект

### Принцип единственной ответственности (Single Responsibility Principle)
Этот принцип уже реализован в классах `Student` | `StudentService` | `StudentView`, а также в классах `StudentGroup` | `StudentGroupService` | `StudentView`. 

Я решил добавить аналогичные классы для учителя `TeacherService` | `TeacherView` | `TeacherController`.

### Принцип открытости закрытости (Open-closed principle)
Данный принцип решил реализовать при помощи *абстракции*. Абстракции — это абстрактные базовые классы, а неограниченный набор возможных поведений представлен всеми возможными *классами-наследниками*. Модуль может манипулировать абстракцией. Такой модуль закрыт для изменений, так как он зависит от фиксированной абстракции. Также поведение модуля может быть расширено созданием новых наследников абстракции. 

Решил сделать класс User абстрактным, добавил ключевое слово abstract в 5-й строчке:
```java
public abstract class User {
``` 
А также сделал метод `toString`в 50 строчке *абстрактным*.

### Принцип подстановки Барбары Лисков (Liskov substitution principle)
Принцип означает, что класс, разработанный путем расширения на основании базового класса, должен переопределять его методы так, чтобы не нарушалась функциональность с точки зрения клиента. То есть, если разработчик расширяет класс и использует его в приложении, он не должен изменять ожидаемое поведение переопределенных методов. В нашем примере если какой то алгоритм обрабатывает объекты родительского класса `User` то ему всегда можно подставить объекты дочерних классов `Student` и `Teacher`, так же создан дочерний класс от класса `Teacher` - **`Professor`** (добавляет ученую степень) который наследует весь функционал класса `Teacher` и может быть подставлен в _ArrayList_.

### Принцип разделения интерфейсов (Interface segregation principle)
Этот принцип похож на принцип единой ответственности **SRP**, **SRP** относится к классам, а **ISP** — к интерфейсам. В частности класс `User` имеет три интерфейса для разных задач, `UserController`, `UserService` и `UserView`, таким образом используются только те методы которые им необходимы, что улучшает код и позволяет лучше поддерживать и расширять его в будущем.

### Принцип инверсии зависимостей (Dependency inversion principle)
Не реализовал.
